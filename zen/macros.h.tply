/// \file macros.h
/// \brief Generic macros used throughout the Zen C++ libraries.
/// 
/// Zen++ comes shipped with some very powerful macros and hacks for
/// automatically generating code. They have been gathered from several places, and
/// have been tested to work on the standard list of compilers. These macros should
/// cover almost all use-cases, and if you're finding yourself missing one, you can
/// always [open up a pull request][1].
///
/// All documented macros can be used in your own code and enable
/// advanced compile-time programming. For example, the 
/// following code makes use of the ZEN_EACH macro:
///
/// ```
/// #define DECLARE_INT(i, value) int ZEN_PASTE_2(var, i) = value;
/// ZEN_EACH(DECLARE_INT, 1, 2, 3, 4)
/// ```
///
/// This snippet generates the following code at compile-time:
/// 
/// ```
/// int foo0 = 1;
/// int foo1 = 2;
/// int foo2 = 3;
/// int foo3 = 4;
/// ```
///
/// ## Macro Primer
///
/// There are two kinds of macros: object-like macros and function-like macros.
///
/// An object-like macro is a basic macro that does not contain any
/// parentheses after the name, like the following example: 
///
/// ```
/// #define FOO 42
/// ```
///
/// Function-like macros are more complex macros that, just like regular C functions, 
/// can accept a limited amount of arguments, which then will be substituted in the
/// macro's body.
///
/// ```
/// #define ASSIGN(a, b) a = b;
/// ```
///
/// Object-like macros are always expanded as soon as possible, with a few exceptions.
/// Function-like macros, on the other hand, can only be expanded when we explicitly provide
/// some arguments to it. Therefore, function-like macros are much more powerful, and are 
/// generally preferred over object-like macros when doing this kind of programming.
///
/// ## The Zen Macros
/// 
/// The following example demonstrates a macro that counts the arguments that are
/// given to it:
/// 
/// ```cpp
/// ZEN_NARG(a, b, c, d) // evaluates to 4
/// ```
/// 
/// This might not seem very useful, but it gets more interesting when the
/// arguments come from another macro:
/// 
/// ```cpp
/// #define DECLARE_INT_ARRAY(name,...) static const int name[ZEN_NARG(__VA_ARGS__)] = { __VA_ARGS__ };
/// 
/// DECLARE_INT_ARRAY(a, b, c, d)
/// ```
/// 
/// Of course, in the previous example we could just omit the array size from the
/// declaration. However there are cases when this macro is extremely useful.
///
/// ## Credits
/// 
/// - The [Mach7 project][2] by Yuri Solodkyy for showing what can be done
///   using nothing more than macros and template metaprogramming.
/// - Laurent Deniau for providing the original idea of how a ZEN_NARGS
///   macro can be written in a [Google Groups discussion][3].
/// - The [P99 project][4] supported by INRIA for providing a modified version
///   of the macro written by Deniau that works even when no arguments were
///   provided.
///
/// [1]: https://github.com/ZenCPP/ZenCPP/pulls
/// [2]: https://github.com/solodon4/Mach7
/// [3]: https://groups.google.com/forum/#!topic/comp.std.c/d-6Mj5Lko_s
/// [4]: https://p99.gforge.inria.fr/
//
// The macros contained in this file were auto-generated.
//
// It is not recommended to edit this file by hand. Instead, tweak the template
// that should be present in one of the source directories.

{!
  max_va_count  = 32
  max_depth     = 10
  max_int_count = 100
!}

#ifndef ZEN_MACROS_H
#define ZEN_MACROS_H

#include <cstdlib>

#define ZEN_EMPTY

#define ZEN_SENTRY() 

#define ZEN_EVAL_1(...) __VA_ARGS__
{% for i in range(1, max_depth) %}
  #define ZEN_EVAL_{{i+1}}(...) ZEN_EVAL_{{i}}({{i}}(__VA_ARGS__))
{% endfor %}

#define ZEN_EVAL(...) ZEN_EVAL_{{max_depth-1}}(__VA_ARGS__)

#define ZEN_DEFER(...) __VA_ARGS__ ZEN_SENTRY()

#define ZEN_APPLY(m,...) m (__VA_ARGS__)

#define ZEN_DISPATCH(m, n, ...) ZEN_PASTE_2(m, n)(__VA_ARGS__)

/* #define ZEN_DISPATCH_HELPER(m, n, ...) ## n (__VA_ARGS__) */

/// This macro holds the maximum number of arguments that were automatically
/// generated by the template engine.
///
/// In some rare cases, a certain macro may accept a few more arguments that
/// weren't automatically generated. However, in practice one should never provide
/// more arguments than the amount that is specified here.
#define ZEN_MAX_ARGS {{max_va_count}}

/// Use this macro anywhere in your code to force a breakpoint.
///
/// The implementation details of this macro may change between versions.
///
#define ZEN_ABORT std::abort();

/// Forcefully terminate the program in order to prevent malicious entities
/// from abusing an illegal state of the program.
///
/// ```
/// match(N)(
///   // ...
///   pattern(_) = [] { ZEN_PANIC("unexpected node"); }
/// )
/// ```
#ifndef NDEBUG
#define ZEN_PANIC(message) \
  fprintf(stderr, "%s: %i: " message, __FILE__, __LINE__); \
  ZEN_ABORT
#else
#define ZEN_PANIC(message) \
  fprintf(stderr, "Program entered a state that was unexpected.\n"); \
  exit(-1);
#endif

/// A macro to prevent the compiler from producing a message about returning
/// an uninitialized variable from a function.
//
/// ```
/// if (state == state_t::foo || type == state_t::bar) {
///   // ...
/// }
//  // The other states should not be active when reaching this function
//  ZEN_UNREACHABLE
/// ```
#define ZEN_UNREACHABLE ZEN_PANIC("unreachable code")

/// A simple macro that only performs assertion checks when not compiling in
/// release mode.
#ifndef NDEBUG
#define ZEN_ASSERT(test) \
  if (!(test)) { \
    ZEN_PANIC("assertion '" #test "' failed"); \
  }
#else
#define ZEN_ASSERT(test)
#endif

#define ZEN_IS__EQ__(...) ,

///
/// Test if the argument list is empty.
///
/// This expands to token 1 if the list was empty and to token 0 if
/// there was anything other than a comment in the list.
///
/// The implementation of this macro is kind of tricky and relies heavily
/// on the fact that a function macro (\c ZEN_IS__EQ__ in this case) is
/// left untouched if it is not followed by a parenthesis. See
/// http://gustedt.wordpress.com/2010/06/08/detect-empty-macro-arguments/
///
/// \warning This macro should work for most reasonable invocations
///          (balanced parenthesis and stuff like that). The only case that
///          definitely does not work is when called with another macro \c X
///          at the end of its argument list, where X itself expects more than one
///          argument.
///          The particular cases where X receives @c 0, @c 1 or a
///          variable number of arguments should be fine.
///
#define ZEN_IS_EMPTY(...)                                   \
  ZEN_IS_EMPTY_HELPER(                                      \
             ZEN_HAS_COMMA( __VA_ARGS__ ),                  \
             ZEN_HAS_COMMA( ZEN_IS__EQ__ __VA_ARGS__ ),     \
             ZEN_HAS_COMMA( __VA_ARGS__ () ),               \
             ZEN_HAS_COMMA( ZEN_IS__EQ__ __VA_ARGS__ () )   \
             )

#define ZEN_IS_EMPTY_HELPER(_0, _1, _2, _3) ZEN_HAS_COMMA(ZEN_PASTE_5(ZEN_IS_EMPTY_CASE_, _0, _1, _2, _3))
#define ZEN_IS_EMPTY_CASE_0000 ZEN_IS_EMPTY_CASE_0000
#define ZEN_IS_EMPTY_CASE_0001 ,
#define ZEN_IS_EMPTY_CASE_0010 ZEN_IS_EMPTY_CASE_0010
#define ZEN_IS_EMPTY_CASE_0011 ZEN_IS_EMPTY_CASE_0011
#define ZEN_IS_EMPTY_CASE_0100 ZEN_IS_EMPTY_CASE_0100
#define ZEN_IS_EMPTY_CASE_0101 ZEN_IS_EMPTY_CASE_0101
#define ZEN_IS_EMPTY_CASE_0110 ZEN_IS_EMPTY_CASE_0110
#define ZEN_IS_EMPTY_CASE_0111 ZEN_IS_EMPTY_CASE_0111
#define ZEN_IS_EMPTY_CASE_1000 ZEN_IS_EMPTY_CASE_1000
#define ZEN_IS_EMPTY_CASE_1001 ZEN_IS_EMPTY_CASE_1001
#define ZEN_IS_EMPTY_CASE_1010 ZEN_IS_EMPTY_CASE_1010
#define ZEN_IS_EMPTY_CASE_1011 ZEN_IS_EMPTY_CASE_1011
#define ZEN_IS_EMPTY_CASE_1100 ZEN_IS_EMPTY_CASE_1100
#define ZEN_IS_EMPTY_CASE_1101 ZEN_IS_EMPTY_CASE_1101
#define ZEN_IS_EMPTY_CASE_1110 ZEN_IS_EMPTY_CASE_1110
#define ZEN_IS_EMPTY_CASE_1111 ZEN_IS_EMPTY_CASE_1111

#define ZEN_NARG_EMPTY_1(N) 0
#define ZEN_NARG_EMPTY_0(N) N

///
/// Return the length of the variable length argument list, where an empty
/// argument list is considered to have 0 arguments.
///
/// This supposes that the length of the list is less than ZEN_MAX_NUMBER.
///
///
#define ZEN_NARG(...) ZEN_NARG__1(ZEN_IS_EMPTY(__VA_ARGS__), ZEN_NARGS(__VA_ARGS__))

#define ZEN_NARG__1(B, N) ZEN_NARG__2(ZEN_PASTE_2(ZEN_NARG_EMPTY_, B), N)
#define ZEN_NARG__2(B, N) B(N)

#define ZEN_SKIP_MAX_ARGS({% join i in range(0, max_va_count+1) with ',' %}_{{i}}{% endjoin %},...) _{{max_va_count}}

// TODO add documentation
// FIXME it might not be necessary to pre-evaluate using ZEN_NARGS_HELPER
#define ZEN_NARGS(...) ZEN_NARGS_HELPER(__VA_ARGS__)

#define ZEN_NARGS_HELPER(...) ZEN_SKIP_MAX_ARGS(__VA_ARGS__,{% join i in reversed(range(0, max_va_count+1)) with ',' %}{{i}}{% endjoin %},)

#define ZEN_HAS_COMMA(...) ZEN_SKIP_MAX_ARGS(__VA_ARGS__,{% join i in range(0, max_va_count-1) with ',' %}1{% endjoin %},0,0)

{% for i in range(0, max_va_count) %}
  #define ZEN_CAT_{{i}}({% join j in range(0, i) with ',' %}_{{j}}{% endjoin %}) {% join j in range(0, i) with ' ## ' %}_{{j}}{% endjoin %}
{% endfor %}

{% for i in range(0, max_va_count) %}
  #define ZEN_PASTE_{{i}}({% join j in range(0, i) with ',' %}_{{j}}{% endjoin %}) ZEN_CAT_{{i}}({% join j in range(0, i) with ',' %}_{{j}}{% endjoin %})
{% endfor %}

/// Concatenates one identifier to another. The identifiers may be
/// complex expressions, as they will be evaluated before concatenation
/// takes place.
#define ZEN_PASTE(...) ZEN_PASTE_2(ZEN_PASTE_, ZEN_NARG(__VA_ARGS__))(__VA_ARGS__)

/// Performs a simple assertion at compile-time, with an
/// easy-to-comprehend message about what went wrong if the assertion
/// failed.
#define ZEN_STATIC_ASSERT(stmt) static_assert(stmt, "Compile-time assertion failed: " #stmt)

/// A macro to disable the 'unused variable' warning in certain compilers.
///
/// This is mainly useful in situations where a lot of variables are
/// auto-generated and it is impossible to predict which ones will be used.
/// 
/// ```
/// #define GENERATE_FOOS(n) ZEN_REPEAT(n, GENERATE_ONE_FOO)
///
/// #define GENERATE_ONE_FOO(i) \
///   int ZEN_PASTE_2(foo, i) = 42; \
///   ZEN_UNUSED(ZEN_PASTE_2(foo, i));
/// ```
#define ZEN_UNUSED(x) (void)x;

/// Indicates how many arguments can be present in a __VA_ARG__ macro variable,
/// and as such how much arguments are supported by this library.
///
/// Note that the C++ standard currently does not specify any
/// requirements about the minimum amount of arguments that is
/// supported, and that different compilers may have very different ///
/// settings.
#define ZEN_VA_MAX_LENGH {{max_va_count}}

#define ZEN_MAYBE_COMMA_0 , 
#define ZEN_MAYBE_COMMA_1
#define ZEN_MAYBE_COMMA(...) ZEN_PASTE_2(ZEN_MAYBE_COMMA_, ZEN_IS_EMPTY(__VA_ARGS__))

{% for i in range(0, max_va_count+1) %}
  #define ZEN_FOR_WITH_{{i}}(s,m,...) {% for j in range(0, i) %}ZEN_APPLY(m, {{j}} ZEN_MAYBE_COMMA(__VA_ARGS__) __VA_ARGS__) s {% endfor %}
{% endfor %}

#define ZEN_FOR_WITH(s,n,m,...) ZEN_DISPATCH(ZEN_FOR_WITH_, n, s, m ZEN_MAYBE_COMMA(__VA_ARGS__) __VA_ARGS__)

/// Repeats the given macro with the specified arguments exactly `n` times.
///
/// The macro `m` receives an additional first argument that contains the
/// current index in the iteration.
///
/// ```
/// #define MAKE_PLACEHOLDER(i) struct ZEN_PASTE_2(_, i) {};
/// ZEN_FOR(10, MAKE_PLACEHOLDER)
/// ```
///
/// ```
/// struct _1 {};
/// struct _2 {};
/// struct _3 {};
/// struct _4 {};
/// struct _5 {};
/// struct _6 {};
/// struct _7 {};
/// struct _8 {};
/// struct _9 {};
/// ```
///
#define ZEN_FOR(n,m,...) ZEN_DISPATCH(ZEN_FOR_WITH_, n, ZEN_EMPTY, m ZEN_MAYBE_COMMA(__VA_ARGS__) __VA_ARGS__)

{% for i in range(0, max_va_count+1) %}
  #define ZEN_FOR_ENUM_{{i}}(m,...) {% for j in range(0, i) %}ZEN_APPLY(m, {{j}} ZEN_MAYBE_COMMA(__VA_ARGS__) __VA_ARGS__) , {% endfor %}
{% endfor %}

#define ZEN_FOR_ENUM(n,m,...) ZEN_DISPATCH(ZEN_FOR_ENUM_, n, m ZEN_MAYBE_COMMA(__VA_ARGS__) __VA_ARGS__)

{% for i in range(0, max_va_count+1) %}
  #define ZEN_JOIN_{{i}}(s,m,...) {% join j in range(0, i) with ' s ' %}ZEN_APPLY(m, {{j}} ZEN_MAYBE_COMMA(__VA_ARGS__) __VA_ARGS__){% endjoin %}
{% endfor %}

/// Repeats the given macro with the specified arguments exactly `n` times. The
/// results of the macro calls are interleaved with whatever value `s` may have.
///
/// ```
/// #define MAKE_PREDICATE(i, name) std::get<i>(name) != nullptr
/// ZEN_JOIN(&&, 4, MAKE_PREDICATE, foo)
/// ```
///
/// ```
///    std::get<0>(foo) != nullptr
/// && std::get<1>(foo) != nullptr
/// && std::get<2>(foo) != nullptr
/// && std::get<3>(foo) != nullptr
/// ```
///
#define ZEN_JOIN(s,n,m,...) ZEN_DISPATCH(ZEN_JOIN_, n, s, m ZEN_MAYBE_COMMA(__VA_ARGS__) __VA_ARGS__)

{% for i in range(0, max_va_count+1) %}
  #define ZEN_JOIN_ENUM_{{i}}(m,...) {% join j in range(0, i) with ' , ' %}ZEN_APPLY(m, {{j}} ZEN_MAYBE_COMMA(__VA_ARGS__) __VA_ARGS__){% endjoin %}
{% endfor %}

/// The same as a call to `ZEN_JOIN` with `s` set to `,`.
///
/// This macro exists solely because the preprocessor treats commas specially.
///
#define ZEN_JOIN_ENUM(n,m,...) ZEN_DISPATCH(ZEN_JOIN_ENUM_, n, m ZEN_MAYBE_COMMA(__VA_ARGS__) __VA_ARGS__)

{% for i in range(0, max_va_count+1) %}
  #define ZEN_VA_GET_{{i}}({% for j in range(0, i+1) %}_{{j}},{% endfor %}...) _{{i}}
{% endfor %}

/// Gets a specific argument from a list of arguments.
///
/// Usually, `__VA_ARGS__` is passed as the second argument to this macro.
///
/// The following example fetches the last argument in the list and
/// ignores all previous arguments except the first:
///
/// ```
/// #define FOO(name, ...) static const int ZEN_PASTE_2(last__, name) = ZEN_VA_GET(ZEN_PRED(ZEN_NARG(__VA_ARGS__)), __VA_ARGS__);
/// ```
/// 
/// \see ZEN_NARG for getting the length of `__VA_ARGS__`.
/// \see ZEN_PRED and ZEN_SUCC increasing or decreasing the argument offset.
#define ZEN_VA_GET(n,...) ZEN_PASTE_2(ZEN_VA_GET_, n)(__VA_ARGS__)

{% for i in range(0, max_va_count+1) %}
  #define ZEN_EACH_WITH_{{i}}(s,m{% for j in range(0, i) %},_{{j}}{% endfor %}) {% join j in range(0, i) with ' s ' %}m(_{{j}}){% endjoin %}
{% endfor %}

/// The same as ZEN_EACH but the generated code fragments are seperated by \p s.
///
/// \see ZEN_EACH
#define ZEN_EACH_WITH(s, m, ...) ZEN_PASTE_2(ZEN_EACH_WITH_, ZEN_NARG(__VA_ARGS__))(s,m,__VA_ARGS__)

/// Generates code fragments by applying the macro \p m to each individual argument passed to ZEN_EACH.
///
/// The macro receives an optional argument \p i that indicates the offset of the argument in the list.
///
/// ```
/// #define DECLARE_INT(i, value) int ZEN_PASTE_2(var, i) = value;
/// ZEN_EACH(DECLARE_INT, 1, 2, 3, 4)
/// ```
///
/// This snippet generates the following code at compile-time:
/// 
/// ```
/// int foo0 = 1;
/// int foo1 = 2;
/// int foo2 = 3;
/// int foo3 = 4;
/// ```
#define ZEN_EACH(m, ...) ZEN_EACH_WITH(, m, __VA_ARGS__)

{% for i in range(0, max_va_count+1) %}
  #define ZEN_EACH_ENUM_{{i}}(m{% for j in range(0, i) %},_{{j}}{% endfor %}) {% join j in range(0, i) with ' , ' %}m(_{{j}}){% endjoin %}
{% endfor %}

/// The same as an invocation to ZEN_EACH_WITH where \p s equals a comma.
///
/// This macro exists because the parser confuses the comma for an empty argument.
///
/// \see ZEN_EACH_WITH if you need to use a seperator other than a comma.
/// \see ZEN_EACH if you require no seperators.
#define ZEN_EACH_ENUM(m, ...) ZEN_PASTE_2(ZEN_EACH_ENUM_, ZEN_NARG(__VA_ARGS__))(m, __VA_ARGS__)

{% for i in range(0, max_int_count) %}
  #define ZEN_INC_{{i}} {{i+1}}
{% endfor %}
#define ZEN_INC(n) ZEN_PASTE_2(ZEN_INC_, n)

/// This macro encapsulates a work-around for a bug in the C++ standard that
/// prevents users from directly moving complex structures into a vector.
///
/// ```
/// ZEN_MOVE_INIT(my_data, std::vector<std::unique_ptr<foo_t>>, std::make_unique<foo_t>(1), std::make_unique<foo_t>(2));
/// return std::move(my_data);
/// ```
///
#define ZEN_MOVE_INIT(name, type, __VA_ARGS__) \
  type::value_type ZEN_PASTE_2(name, __data)[] = { __VA_ARGS__ }; \
  type name { std::make_move_iterator(std::begin(ZEN_PASTE_2(name, __data))), std::make_move_iterator(std::end(ZEN_PASTE_2(name, __data))) };

#endif // #ifndef ZEN_MACROS_H
